// ---------------------------------------------------------------------
// This file is auto-generated by behaviac designer, so please don't modify it by yourself!
// ---------------------------------------------------------------------

#ifndef BEHAVIAC_MEMBER_VISITOR_H
#define BEHAVIAC_MEMBER_VISITOR_H

#include "behaviac_agent_headers.h"

// Agent property and method handlers

namespace behaviac
{
	struct METHOD_TYPE_behaviac_Agent_VectorAdd { };
	template<> inline void Agent::_Execute_Method_<METHOD_TYPE_behaviac_Agent_VectorAdd>(IList& p0, System::Object& p1)
	{
		this->behaviac::Agent::VectorAdd(p0, p1);
	}

	struct METHOD_TYPE_behaviac_Agent_VectorClear { };
	template<> inline void Agent::_Execute_Method_<METHOD_TYPE_behaviac_Agent_VectorClear>(IList& p0)
	{
		this->behaviac::Agent::VectorClear(p0);
	}

	struct METHOD_TYPE_behaviac_Agent_VectorContains { };
	template<> inline bool Agent::_Execute_Method_<METHOD_TYPE_behaviac_Agent_VectorContains>(IList& p0, System::Object& p1)
	{
		return this->behaviac::Agent::VectorContains(p0, p1);
	}

	struct METHOD_TYPE_behaviac_Agent_VectorLength { };
	template<> inline int Agent::_Execute_Method_<METHOD_TYPE_behaviac_Agent_VectorLength>(IList& p0)
	{
		return this->behaviac::Agent::VectorLength(p0);
	}

	struct METHOD_TYPE_behaviac_Agent_VectorRemove { };
	template<> inline void Agent::_Execute_Method_<METHOD_TYPE_behaviac_Agent_VectorRemove>(IList& p0, System::Object& p1)
	{
		this->behaviac::Agent::VectorRemove(p0, p1);
	}

}

struct METHOD_TYPE_Enemy_getEnemyType { };
template<> inline int Enemy::_Execute_Method_<METHOD_TYPE_Enemy_getEnemyType>()
{
	return this->Enemy::getEnemyType();
}

struct METHOD_TYPE_Enemy_getRandomSpeedByInitSpeed { };
template<> inline float Enemy::_Execute_Method_<METHOD_TYPE_Enemy_getRandomSpeedByInitSpeed>(float p0)
{
	return this->Enemy::getRandomSpeedByInitSpeed(p0);
}

struct METHOD_TYPE_Enemy_getSpeed { };
template<> inline float Enemy::_Execute_Method_<METHOD_TYPE_Enemy_getSpeed>()
{
	return this->Enemy::getSpeed();
}

struct METHOD_TYPE_Enemy_isAlive { };
template<> inline bool Enemy::_Execute_Method_<METHOD_TYPE_Enemy_isAlive>()
{
	return this->Enemy::isAlive();
}

struct METHOD_TYPE_Enemy_setSpeed { };
template<> inline void Enemy::_Execute_Method_<METHOD_TYPE_Enemy_setSpeed>(float p0)
{
	this->Enemy::setSpeed(p0);
}

struct PROPERTY_TYPE_Hero_m_isAI { };
template<> inline bool& Hero::_Get_Property_<PROPERTY_TYPE_Hero_m_isAI>()
{
	unsigned char* pc = (unsigned char*)this;
	pc += (int)BEHAVIAC_OFFSETOF(Hero, Hero::m_isAI);
	return *(reinterpret_cast<bool*>(pc));
}

struct METHOD_TYPE_Hero_AdjustHeroPosition { };
template<> inline void Hero::_Execute_Method_<METHOD_TYPE_Hero_AdjustHeroPosition>()
{
	this->Hero::AdjustHeroPosition();
}

struct METHOD_TYPE_Hero_EscapeEnemyCrash { };
template<> inline void Hero::_Execute_Method_<METHOD_TYPE_Hero_EscapeEnemyCrash>()
{
	this->Hero::EscapeEnemyCrash();
}

struct METHOD_TYPE_Hero_findAnEnemyAndAttack { };
template<> inline void Hero::_Execute_Method_<METHOD_TYPE_Hero_findAnEnemyAndAttack>()
{
	this->Hero::findAnEnemyAndAttack();
}

struct METHOD_TYPE_Hero_findAnNearestEnemy { };
template<> inline void Hero::_Execute_Method_<METHOD_TYPE_Hero_findAnNearestEnemy>()
{
	this->Hero::findAnNearestEnemy();
}

struct METHOD_TYPE_Hero_hasEnemyInFrontCanAttack { };
template<> inline bool Hero::_Execute_Method_<METHOD_TYPE_Hero_hasEnemyInFrontCanAttack>()
{
	return this->Hero::hasEnemyInFrontCanAttack();
}

struct METHOD_TYPE_Hero_isWillBeCrashOnNearestEnemy { };
template<> inline bool Hero::_Execute_Method_<METHOD_TYPE_Hero_isWillBeCrashOnNearestEnemy>()
{
	return this->Hero::isWillBeCrashOnNearestEnemy();
}

struct METHOD_TYPE_Hero_wait20Frame { };
template<> inline bool Hero::_Execute_Method_<METHOD_TYPE_Hero_wait20Frame>()
{
	return this->Hero::wait20Frame();
}

struct PROPERTY_TYPE_NPC_Level1Up_Score { };
template<> inline int& NPC::_Get_Property_<PROPERTY_TYPE_NPC_Level1Up_Score>()
{
	unsigned char* pc = (unsigned char*)this;
	pc += (int)BEHAVIAC_OFFSETOF(NPC, NPC::Level1Up_Score);
	return *(reinterpret_cast<int*>(pc));
}

struct PROPERTY_TYPE_NPC_Level2Up_Score { };
template<> inline int& NPC::_Get_Property_<PROPERTY_TYPE_NPC_Level2Up_Score>()
{
	unsigned char* pc = (unsigned char*)this;
	pc += (int)BEHAVIAC_OFFSETOF(NPC, NPC::Level2Up_Score);
	return *(reinterpret_cast<int*>(pc));
}

struct PROPERTY_TYPE_NPC_Level3Up_Score { };
template<> inline int& NPC::_Get_Property_<PROPERTY_TYPE_NPC_Level3Up_Score>()
{
	unsigned char* pc = (unsigned char*)this;
	pc += (int)BEHAVIAC_OFFSETOF(NPC, NPC::Level3Up_Score);
	return *(reinterpret_cast<int*>(pc));
}

struct PROPERTY_TYPE_NPC_Level4Up_Score { };
template<> inline int& NPC::_Get_Property_<PROPERTY_TYPE_NPC_Level4Up_Score>()
{
	unsigned char* pc = (unsigned char*)this;
	pc += (int)BEHAVIAC_OFFSETOF(NPC, NPC::Level4Up_Score);
	return *(reinterpret_cast<int*>(pc));
}

struct PROPERTY_TYPE_NPC_m_canBossRefresh { };
template<> inline bool& NPC::_Get_Property_<PROPERTY_TYPE_NPC_m_canBossRefresh>()
{
	unsigned char* pc = (unsigned char*)this;
	pc += (int)BEHAVIAC_OFFSETOF(NPC, NPC::m_canBossRefresh);
	return *(reinterpret_cast<bool*>(pc));
}

struct PROPERTY_TYPE_NPC_m_level { };
template<> inline int& NPC::_Get_Property_<PROPERTY_TYPE_NPC_m_level>()
{
	unsigned char* pc = (unsigned char*)this;
	pc += (int)BEHAVIAC_OFFSETOF(NPC, NPC::m_level);
	return *(reinterpret_cast<int*>(pc));
}

struct METHOD_TYPE_NPC_getLevel { };
template<> inline int NPC::_Execute_Method_<METHOD_TYPE_NPC_getLevel>(int p0)
{
	return this->NPC::getLevel(p0);
}

struct METHOD_TYPE_NPC_setLeveUpScore { };
template<> inline void NPC::_Execute_Method_<METHOD_TYPE_NPC_setLeveUpScore>(int p0, int p1)
{
	this->NPC::setLeveUpScore(p0, p1);
}

struct METHOD_TYPE_NPC_spawnEnemy { };
template<> inline void NPC::_Execute_Method_<METHOD_TYPE_NPC_spawnEnemy>()
{
	this->NPC::spawnEnemy();
}

#endif // BEHAVIAC_MEMBER_VISITOR_H
